---
title: "CMU 15-445 lec15, 16, 17, 18"
description: "这是一篇关于 CMU 15-445 数据库导论 lecture15 和 lecture18 的笔记，主要讲讲DBMS的并发控制。"
pubDatetime: 2024-07-25
author: Zari Tsu
featured: false
draft: false
tags:
  - Database
---

# Concurrency Control

### Strawman System

执行事务时，DBMS会复制整个数据库文件，并将事务更改到此新文件中。如果事务成功，则新文件将成为当前数据库文件。如果事务失败，DBMS将丢弃新文件，并且事务的任何更改都不会被保存。此方法速度较慢，因为它不允许并发事务，并且需要为每个事务复制整个数据库文件。

## ACID

ACID是用于确保数据库正确性的标准

### Atomicity

事务是一个不可分割的工作单位，事务中包括的操作要么全部完成，要么全部不完成。

* 一种实现方法是日志(logging)，记录了改变什么，以防后面回滚
* 另一种是拷贝的备份(Shadow Paging)，名字就已经把做法表达出来了。这种方法效率低但是恢复效果好，但是效率重于一切，现实中很少使用。

### Consistency

事务必须确保数据库的完整性，事务的执行不能破坏数据库的一致性。

我们要保证DB是符合逻辑的(logical)，包括两点，DataBase Consistency and Data Consistency。就是说DB本身要合理，比如岁数非负这种，此外txn也要合理，不能因为执行了某个事务导致其他事务的结果不一致。

### **Isolation**

事务之间彼此隔离，一个事务的执行不能影响其他事务的执行。

这个概念很像操作系统的进程，每个事务都认为自己独占了所有资源，运行的时候没有别人干扰。

悲观(Pessimistic)：DBMS假设事务会发生冲突，所以它一开始就不允许让程序出现问题。

乐观(Optimistic)：DBMS假设事务之间的冲突很少，因此它选择在事务提交后发生冲突时处理冲突。

> 笼统怎么做：
> 
> 1. 不交错不同事务操作的计划。
> 2. 对于任何数据库状态，如果执行第一个计划的效果与执行第二个计划的结果相同，则这两个计划是等效的。
> 3. 不同的串行执行可以产生不同的结果，但都被认为是“正确的”。

> 三种冲突
>
> 1. 读-写冲突（“不可重复读取”）：当多次读取同一对象时，事务无法获得相同的值。
> 2. 写-读冲突（“脏读”）：在事务提交更改之前，事务会看到不同事务的写效果。
> 3. 写-写冲突（“丢失的更新”）：一个事务会覆盖另一个并发事务的未提交数据。

> 序列化 (Serializability)
>
> 1. Conflict Serializability: 当事务遇到冲突时(即多个事务在同一时间访问/修改相同的数据)，必须按照一定顺序串行执行，直到所有冲突都解决。这个顺序或者说优先级的调停，由precedence graph来决定。
> 2. View Serializability: 事务的执行顺序与视图的依赖关系一致，即按照视图的定义来串行执行，注意它也不常用。(Blind Writes: 即写前不读，就直接莽上手)

### Durability

事务一旦提交，它对数据库的修改就永久保存。

又称Persistent，即使在crash之后依旧不丢失数据，就类似File System的持久化。
