---
title: "CMU 15-445 lec7, 8"
description: "这是一篇关于 CMU 15-445 数据库导论 lecture7 和 lecture8 的笔记，主要讲了DBMS是如何从硬盘中读取内容到内存中的，以及DB的数据结构Hash Table和B-Tree"
pubDatetime: 2024-07-03
author: Zari Tsu
featured: false
draft: false
tags:
  - Database
---

# lecture 7 - 8

## Hash Table

Hash Table这个概念已经讲烂了，不必多说了。在课程当中，非常学术性地对其分了几个类

1. Static Hashing Schemes: 静态哈希策略，指的是在创建表的时候就已经确定好了哈希函数，并且哈希函数的选择是固定的。然后扩展的方式类似于vector，每次都要重新创建整个表，并将大小设置为两倍。
   1. Linear Probe Hashing: 线性探测，当发生冲突时，通过一个固定的步长来探测下一个空槽，直到找到一个空槽。
   2. Cuckoo Hashing: 布谷鸟散列，当发生冲突时，将两个元素交换位置，然后再散列，直到找到一个空槽。
2. Dynamic Hashing Schemes: 动态哈希策略，指的是在创建表的时候并不确定哈希函数，而是在运行时根据需要动态调整。
   1. Chained Hashing: 链接法，将哈希表的每个槽链接成一个链表，当发生冲突时，将元素插入到链表的尾部。(我们最熟悉的)
   2. Extendible Hashing: 可扩展哈希，当发生冲突时，将元素插入到链表的尾部。允许哈希表中的多个槽位置指向同一个链。
   3. Linear Hashing: 线性哈希，将哈希表的大小设置为一个质数，然后将元素的哈希值对质数取模，得到索引。跟Probe不同的是，当溢出时会采用分割并换用不同哈希函数的办法。

## Tree Indexes

这个差不多就是一种键值对的形式，由索引得到数据的过程。

B+Tree跟B-Tree大致一样，区别在于后者在每个节点都存储了值，而B+Tree只有在叶子节点才存储值。

B+Tree的每个节点除了存储键值对外，还存储了指针，指向子节点。这样可以减少磁盘IO，提高查询效率。B+Tree的每个节点都包含一个键/值对数组。

形式上，B+Tree是一个M向搜索树（其中M表示一个节点可以拥有的最大子节点数），具有以下属性: 
1. 它是完全平衡的，即每个叶节点有相同的深度
2. 根以外的每个内部节点都至少有一半已满，即对于每个节点容量为`M`的树，至少有`M/2`个子节点，或者说至少有`M/2`个键值对。
3. 每个具有`k`个键的内部节点都有`k+1`个非空子节点。这个就类似于一根绳子被切了`k`刀，那么它会被分成`k+1`段。

所以有几个推论: 
1. 若节点存在空键，空键将聚集在第一个叶节点或最后一个叶节点中，根据索引类型（先为NULL或者后为NULL）。
2. 由于每个节点都有指针，所以查询的效率是`O(log n)`，其中n是树的高度。
3. 由于每个节点都有指针，所以插入和删除的效率是`O(log n)`。

### 对B+Tree的操作

* Insertion: 遍历树并使用内部节点来确定要将键插入的叶节点
  1. 找到正确的叶子节点L
  2. 将新entry(即键值对)插入到L当中，如果节点没满直接结束插入
  3. 如果L满了，则将L均匀分裂成两个节点$$L_{1}$$和$$L_{2}$$，并向上复制中间键，将指向$$L_2$$的条目插入原先L的父项

* Deletion: 在插入中，当树太满时，我们偶尔不得不拆分叶子；如果删除导致树不到半满，我们必须合并(merge)以重新平衡树
  1. 找到正确的叶子节点L
  2. 删除entry(即键值对)，如果L还是超过一半满的话，结束删除
  3. 尝试重新分配，向Sibling节点借个键值对过来
  4. 如果重新分配也失败了，直接合并L和Sibling节点，并必须删除父级中指向L的条目

